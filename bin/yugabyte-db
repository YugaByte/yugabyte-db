#!/usr/bin/env python

import argparse
import atexit
import json
import logging
import multiprocessing
import os
import sys
import time
import re
import shutil
import subprocess
import uuid
from datetime import datetime
from signal import SIGABRT, SIGINT, SIGTERM, SIG_DFL, signal
from threading import Thread

# Version-dependent imports
PY_VERSION = sys.version_info[0]
if sys.version_info[0] < 3:
    from urllib2 import Request, urlopen, URLError
else:
    from urllib.request import Request, urlopen
    from urllib.error import URLError

"""
Run `yugabyte-db` to start a single-node YugaByte DB process. If no options are specified,
`yugabyte-db` will assume the following default directory tree:

yugabyte
+-- yugabyte-db
+-- conf
|   |   +-- yugabyte-db.conf
|   |   +-- yb-master.conf
|   |   +-- yb-tserver.conf
+-- bin
|   |   +-- yb-master
|   |   +-- yb-tserver
+-- logs
|   |   +-- master & tserver logfiles, unify these if possible
+-- yugabyte-data
"""

YUGABYTE_DIR = os.path.dirname(os.path.realpath(__file__))
DEFAULT_CONF_DIR = os.path.join(YUGABYTE_DIR, "conf")
BIN_DIR = os.path.join(YUGABYTE_DIR, "bin")
DEFAULT_DATA_DIR = os.path.join(YUGABYTE_DIR, "yugabyte-data")
DEFAULT_LOG_DIR = os.path.join(YUGABYTE_DIR, "yugabyte-logs")
DEFAULT_CONF = os.path.join(DEFAULT_CONF_DIR, "yugabyte-db.conf")
DEFAULT_MASTER_PORT = 7100
DEFAULT_YSQL_PORT = 5433
DEFAULT_YCQL_PORT = 9042
VERSION_METADATA_PATH = os.path.join(YUGABYTE_DIR, "version_metadata.json")
YUGABYTE_API_CLIENT_PROGRAMS = {
    "ysql": "ysqlsh",
    "ycql": "cqlsh",
}


class YugaByteProcessManager(object):
    def __init__(self):
        self.configs = None
        self.processes = {}
        self.stop_callhome = False

    # Starts YugaByte DB node.
    def start(self):
        print_and_log("Starting YugaByte DB...")
        self.set_signals(self.kill_yugabyte)
        atexit.register(self.kill_yugabyte)
        self.start_processes()

    # Prints status of YugaByte DB.
    def status(self):
        if os.path.isdir(self.configs.saved_data.get("data_dir")):
            if self.get_failed_processes():
                print("YugaByte DB is not running.")
            print(self.get_status_string())
        else:
            print("YugaByte DB is not running.")

    # Prints YugaByte DB version.
    def version(self):
        title = "YugaByte DB Information"
        with open(VERSION_METADATA_PATH) as metadata:
            data = json.load(metadata)
            info_kv_list = [
                ("Version", "{}-b{}".format(data.get("version_number"), data.get("build_number"))),
                ("Build Time", data.get("build_timestamp")),
                ("Build Hash", data.get("git_hash"))]
            print(self.get_status_string())

    # Starts an interactive YSQL shell.
    def connect_ysql(self):
        if self.get_failed_processes():
            log_error_and_exit("YugaByte DB is not running. Cannot connect to YSQL.")
        ysql_proxy = YsqlProxy(self.configs.saved_data.get("ysql_port"))
        ysql_proxy.connect()

    # Starts an interactive YCQL shell.
    def connect_ycql(self):
        if self.get_failed_processes():
            log_error_and_exit("YugaByte DB is not running. Cannot connect to YCQL.")
        path = os.path.join(BIN_DIR, YUGABYTE_API_CLIENT_PROGRAMS["ycql"])
        cmd = [path, "127.0.0.1", self.configs.saved_data.get("ycql_port")]
        os.execv(path, cmd)

    # Create retail database if it does not exist.
    def create_demo_retail(self):
        if self.get_failed_processes():
            log_error_and_exit("YugaByte DB is not running. Cannot create sample database.")

        demo_db = "yb_demo_retail"
        ysql_proxy = YsqlProxy(self.configs.saved_data.get("ysql_port"))
        if not ysql_proxy.db_exists(demo_db):
            # Create demo database.
            print_and_log("Creating database {}...".format(demo_db))
            _, err = ysql_proxy.create_db(demo_db)
            if err:
                log_error_and_exit("Failed to create {} database: {}".format(demo_db, err))

            # Populate demo database.
            print_and_log("Populating {} with sample data...".format(demo_db))
            files = []
            for name in ("schema.sql", "products.sql", "users.sql", "reviews.sql", "orders.sql"):
                files.append(os.path.join(YUGABYTE_DIR, "share", name))
            _, err = ysql_proxy.load_files(files, db=demo_db)
            if err:
                log_error_and_exit("Failed to populate data to {}: {}".format(demo_db, err))

            print_and_log("Successfully loaded sample database!")
            print(
                "\n################################\n"
                "# WELCOME TO THE retail DEMO\n"
                "################################\n"
                "    Database: yb_demo_retail\n"
                "    |_ users\n"
                "    |_ products\n"
                "    |_ orders\n"
                "    |_ reviews\n\n"
                "################################\n"
                "# NEXT STEP: RUN THE DEMO\n"
                "################################\n"
                "$ yugabyte-db demo run retail\n\n"
            )
        else:
            print_and_log(
                "Retail sample database has already been created. "
                "Use `yugabyte-db demo run retail` to interact with it.")

    # Run YSQL shell in retail database.
    def run_demo_retail(self):
        if self.get_failed_processes():
            log_error_and_exit("YugaByte DB is not running. Cannot connect to YSQL.")

        demo_db = "yb_demo_retail"
        ysql_proxy = YsqlProxy(self.configs.saved_data.get("ysql_port"))
        if ysql_proxy.db_exists(demo_db):
            # TODO: Add more commands.
            print(
                "\n################################\n"
                "# SAMPLE QUERIES TO TRY\n"
                "################################\n\n"
                "# JOINS (find user details of orders):\n"
                "    SELECT users.id, users.name, users.email, orders.id, orders.total\n"
                "        FROM orders INNER JOIN users ON orders.user_id=users.id\n"
                "        LIMIT 10;\n\n"
                "For more, go to https://docs.yugabyte.com/latest/quick-start/explore-ysql/\n"
            )
            ysql_proxy.connect(db="yb_demo_retail")
        else:
            log_error_and_exit(
                "Retail demo has not been created. Run `yugabyte-db demo create retail`.")

    # Destroy retail database if it exists.
    def destroy_demo_retail(self):
        if self.get_failed_processes():
            log_error_and_exit("YugaByte DB is not running. Cannot destroy sample database.")

        demo_db = "yb_demo_retail"
        ysql_proxy = YsqlProxy(self.configs.saved_data.get("ysql_port"))
        if not ysql_proxy.db_exists(demo_db):
            log_error_and_exit("Failed to destroy database. Retail demo has not been created.")
        else:
            _, err = ysql_proxy.drop_db(demo_db)
            if err:
                log_error_and_exit("Failed to drop database {}: {}".format(demo_db, err))
            print_and_log("Successfully destroyed demo database {}.".format(demo_db))

    # Checks yb-master and yb-tserver are running. Returns failed processes.
    # TODO: Check postmaster.pid.
    def get_failed_processes(self):
        failed_processes = []
        for process in ("master", "tserver"):
            if not ProcessManager.is_process_running(
                    process, self.configs.saved_data.get("data_dir")):
                failed_processes.append("yb-{}".format(process))
        return failed_processes

    # Called after receiving certain signals or on exit. Kills all subprocesses.
    def kill_yugabyte(self, signum=None, frame=None):
        print_and_log("Shutting down...")
        cur_pid = os.getpid()
        pgid = os.getpgid(cur_pid)
        if not pgid:
            log_error_and_exit(
                "PGID could not be found for PID {}. Is YugaByte DB running?".format(cur_pid))

        self.set_signals(SIG_DFL)

        for p in self.processes.values():
            p.delete_pidfile()

        try:
            # Kill process group instead of self.processes to ensure
            # any spawned child processes are killed
            os.killpg(pgid, SIGTERM)
            log_error_and_exit(
                "YugaByte DB may not have terminated properly... "
                "Please check PGID {}.".format(pgid))
        except OSError as err:
            log_error_and_exit(
                "Failed to kill PGID {}... Is YugaByte DB running?\n{}".format(pgid, str(err)))

    # Starts yb-master and yb-tserver processes.
    # After initializing, creates a callhome thread.
    def start_processes(self):
        common_gflags = [
            "--stop_on_parent_termination",
            "--undefok=stop_on_parent_termination",
            "--fs_data_dirs={}".format(self.configs.saved_data.get("data_dir")),
            "--rpc_bind_addresses", "127.0.0.1"]
        master_address = "127.0.0.1:{}".format(self.configs.saved_data.get("master_port"))
        yb_master_cmd = [os.path.join(BIN_DIR, "yb-master")] + common_gflags + \
            ["--master_addresses={}".format(master_address),
            #  "--rpc_bind_addresses", "127.0.0.1:{}".format(self.configs.master_port),
             "--replication_factor", "1",
             "--use_initial_sys_catalog_snapshot",
             "--server_dump_info_path",
             os.path.join(self.configs.saved_data.get("data_dir"), "master-info"),]
        yb_tserver_cmd = [os.path.join(BIN_DIR, "yb-tserver")] + common_gflags + \
            ["--tserver_master_addrs={}".format(master_address),
             "--cql_proxy_bind_address",
             "127.0.0.1:{}".format(self.configs.saved_data.get("ycql_port")),
             "--server_dump_info_path",
             os.path.join(self.configs.saved_data.get("data_dir"), "tserver-info"),
             "--start_pgsql_proxy", "--pgsql_proxy_bind_address",
             "127.0.0.1:{}".format(self.configs.saved_data.get("ysql_port"))]

        self.processes = {
            "master": YBProcessManager(
                "master", yb_master_cmd, self.configs.saved_data.get("log_dir"),
                self.configs.saved_data.get("data_dir")),
            "tserver": YBProcessManager(
                "tserver", yb_tserver_cmd, self.configs.saved_data.get("log_dir"),
                self.configs.saved_data.get("data_dir"))
        }

        for p in self.processes.values():
            pid = p.get_pid()
            if pid:
                print("YugaByte DB is already running!")
                # Clear self.processes so kill_yugabyte() doesn't kill existing processes.
                self.processes = {}
                return

        is_first_run = True
        callhome_thread = None
        self.stop_callhome = False
        while True:
            should_callhome = False

            # Delete corrupted data dirs left from interrupting yb-master and yb-tserver startup.
            if not self.is_yb_initialized() and os.path.exists(self.configs.saved_data.get("data_dir")):
                print_and_log(
                    "Found data from failed initialization in {}. Removing...".format(
                        self.configs.saved_data.get("data_dir")))
                shutil.rmtree(self.configs.saved_data.get("data_dir"))

            # Create data directory.
            if not os.path.exists(self.configs.saved_data.get("data_dir")):
                print_and_log(
                    "Creating data directory {}.".format(self.configs.saved_data.get("data_dir")))
                os.makedirs(self.configs.saved_data.get("data_dir"))

            # Start or initialize yb-master and yb-tserver.
            for name in ("master", "tserver"):
                process = self.processes.get(name)
                if not process.is_running():
                    process.start()
                    trigger = "start_{},".format(name)
                    if not is_first_run:
                        trigger = "restart_{},".format(name)
                        print_and_log(
                            "{} died unexpectedly. Restarting...".format(p.name), logging.ERROR)
                    should_callhome = True

            self.wait_yb_master()
            if should_callhome:
                self.callhome()

            # Print startup information and start callhome thread on first successful startup.
            if is_first_run:
                first_run_success = True
                for p in self.processes.values():
                    if not p.is_running():
                        first_run_success = False
                        break

                if first_run_success and self.is_yb_initialized():
                    startup_info = self.get_status_string() + \
                        "YugaByte DB started successfully!\n" \
                        "For help, join us on Slack at https://www.yugabyte.com/slack.\n"
                    print(startup_info)

                callhome_thread = Thread(target=self.callhome_loop)
                callhome_thread.start()
                is_first_run = False

            time.sleep(int(self.configs.saved_data.get("polling_interval")))

        # Stop callhome. Useful in future if we do anything after quitting.
        self.stop_callhome = True
        callhome_thread.join()

    # Returns if yb-master and yb-tserver were properly initialized before.
    def is_yb_initialized(self):
        for info_file in ("master-info", "tserver-info", "tserver-info-redis", "tserver-info-cql"):
            if not os.path.exists(os.path.join(self.configs.saved_data.get("data_dir"), info_file)):
                return False
        return True

    # Rudimentary yb-admin call. TODO: update.
    def get_universe_uuid(self):
        saved_uuid = self.configs.saved_data.get("universe_uuid")
        if saved_uuid:
            return saved_uuid
        elif not self.get_failed_processes():
            cmd = [os.path.join(BIN_DIR, "yb-admin"), "get_universe_config"]
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = process.communicate()
            if stdout:
                universe_configs = stdout.split()
                if universe_configs:
                    univ_uuid = universe_configs[-1].replace('"', '')
                    self.configs.saved_data["universe_uuid"] = univ_uuid
                    self.configs.save_configs()
                    return univ_uuid
        return None

    # TODO: Use yb-admin to wait for yb-master to be ready.
    def wait_yb_master(self, timeout=5):
        time.sleep(timeout)
        return True

    # Returns pretty output table.
    def get_status_string(self):
        title = "YugaByte DB"
        status_info = [
            ("JDBC", "postgresql://postgres@127.0.0.1:{}".format(
                self.configs.saved_data.get("ysql_port"))),
            ("YSQL", "yugabyte-db connect ysql"),
            ("YCQL", "yugabyte-db connect ycql"),
            ("Web UI", "http://127.0.0.1:7000"),
            ("Data Dir", self.configs.saved_data.get("data_dir")),
            ("Universe UUID", self.get_universe_uuid())
        ]
        status = "\n" + "-" * 100 + "\n"
        status += "| {:<96} |\n".format(title)
        status += "-" * 100 + "\n"
        for k, v in status_info:
            status += "| {:20}: {:<74} |\n".format(k, v)
        status += "-" * 100 + "\n"
        return status

    # Callhome loop. Sends data every minute for the first hour, then every hour after.
    def callhome_loop(self):
        num_times_called = 0
        initial_interval = 60
        final_interval = 3600
        while not self.stop_callhome:
            try:
                self.callhome()
            except URLError as e:
                logging.error("Failed to send callhome: %s", str(e))
            num_times_called += 1
            # Send callhome data more often in initial hour.
            time.sleep(initial_interval if num_times_called < 60 else final_interval)

    # Collects callhome data and sends it.
    def callhome(self):
        url = "http://diagnostics.yugabyte.com"
        headers = {
            "Content-Type": "application/json",
            "User-Agent": "Mozilla",
        }
        data = Diagnostics(self.configs).get_data(self.processes)
        req = Request(url, headers=headers, data=data)
        resp = urlopen(req)

    # Calls func after receiving certain exit signals.
    def set_signals(self, func):
        for sig in (SIGABRT, SIGINT, SIGTERM):
            signal(sig, func)

    # Parse config file and input args. Validate them and save any new configs.
    def validate_and_set_configs(self, args):
        has_errors = False
        conf_dir = os.path.dirname(args.config)
        if not os.path.isdir(conf_dir):
            os.makedirs(conf_dir)

        self.conf_file = args.config
        self.configs = Configs.parse_config_file(self.conf_file)

        for path_args in ("data_dir", "config", "log_dir"):
            path = getattr(args, path_args, None)
            if path:
                setattr(args, path_args, os.path.realpath(path))

        if args.parser == "start":
            if args.data_dir:
                config_data_dir = self.configs.saved_data.get("data_dir")
                if (config_data_dir and os.path.exists(config_data_dir) and
                        config_data_dir != args.data_dir):
                    has_errors = True
                    # TODO: Gradefully handle this case... User should be able to override config.
                    print(
                        "Data directory already exits at {}.".format(config_data_dir))
            if args.log_dir:
                config_log_dir = self.configs.saved_data.get("log_dir")
                if (config_log_dir and os.path.exists(config_log_dir) and
                        config_log_dir != args.log_dir):
                    print(
                        "Old log directory already exists at {}. New logs will go to {}".format(
                            config_log_dir, args.log_dir))

        if has_errors:
            sys.exit(1)

        # Override configs and defaults with user specified variables
        update_config_file = False
        for k, v in get_kv(args.__dict__):
            if v and k in self.configs.saved_data and v != self.configs.saved_data.get(k):
                self.configs.saved_data[k] = v
                update_config_file = True

        if update_config_file:
            self.configs.save_configs()

    def run(self):
        # Parent subparser for common args
        common_parser = argparse.ArgumentParser(add_help=False)
        common_parser.add_argument(
            "--config", default=DEFAULT_CONF, help="Yugabyte DB configuration file")
        # TODO: Refactor data_dir to be a list for multi-node.
        common_parser.add_argument(
            "--data_dir", help="Directory where YugaByte DB will store data.")

        parser = argparse.ArgumentParser()
        all_parsers = {"default": parser}
        subparsers = parser.add_subparsers(dest="parser")
        for cmd, description in (
                ("status", "Print status of YugaByte DB."),
                ("version", "Version of YugaByte DB."),
                ("start", "Start YugaByte DB."),):
            subparser = subparsers.add_parser(cmd, help=description, parents=[common_parser])
            func = getattr(self, cmd, None)
            subparser.set_defaults(func=func)
            all_parsers[cmd] = subparser

        # Add ysql and ycql CLI options
        connect = subparsers.add_parser("connect", help="Connect to an API through the CLI.")
        all_parsers["connect"] = connect
        connect_subparser = connect.add_subparsers()
        for api in YUGABYTE_API_CLIENT_PROGRAMS:
            cur_parser = connect_subparser.add_parser(
                api, help="Use {} through the CLI.".format(api.upper()), parents=[common_parser])
            func = getattr(self, "connect_{}".format(api), None)
            cur_parser.set_defaults(func=func)
            all_parsers[api] = cur_parser

        # Add YSQL demo commands.
        demo = subparsers.add_parser("demo", help="Load and interact with preset demo data.")
        all_parsers["demo"] = demo
        demo_subparser = demo.add_subparsers()

        # TODO: Make below code readable...
        create_help = "Create sample database if it does not exist yet."
        create_demo = demo_subparser.add_parser("create", help=create_help)
        create_demo_subparser = create_demo.add_subparsers()
        run_help = "Open interactive shell in sample database."
        run_demo = demo_subparser.add_parser("run", help=run_help)
        run_demo_subparser = run_demo.add_subparsers()
        destroy_help = "Destroy sample database."
        destroy_demo = demo_subparser.add_parser("destroy", help=destroy_help)
        destroy_demo_subparser = destroy_demo.add_subparsers()
        for demo_type, demo_help in (
                ("retail", "Retail is a database with products, users, orders, and reviews."),):
            for action, action_help, cur_subparser in (
                    ("create", create_help, create_demo_subparser),
                    ("destroy", destroy_help, destroy_demo_subparser),
                    ("run", run_help, run_demo_subparser)):
                help_msg = "{} {}".format(action_help, demo_help)
                cur_parser = cur_subparser.add_parser(
                    demo_type, help=help_msg, parents=[common_parser])
                func = getattr(self, "{}_demo_{}".format(action, demo_type), None)
                cur_parser.set_defaults(func=func)
                all_parsers["{}_{}".format(action, demo_type)] = cur_parser

        # Commands that can alter configuration file.
        for cmd in ("start",):
            cur_parser = all_parsers[cmd]
            cur_parser.add_argument(
                "--log_dir", help="Directory to store YugaByte DB logs.")
            cur_parser.add_argument(
                "--ycql_port", help="Port on which YCQL will run.")
            cur_parser.add_argument(
                "--ysql_port", help="Port on which YSQL will run.")
            # Hidden commands for development/advanced users
            cur_parser.add_argument(
                "--polling_interval", default=5, help=argparse.SUPPRESS)

        for _, cur_parser in get_kv(all_parsers):
            cur_parser._positionals.title = "Commands"
            cur_parser._optionals.title = "Flags"

        if not sys.argv[1:]:
            parser.print_help()
            return

        args = parser.parse_args()
        self.validate_and_set_configs(args)

        log_dir = self.configs.saved_data.get("log_dir")
        if not os.path.exists(log_dir):
            print("Creating log directory {}.".format(log_dir))
            os.makedirs(log_dir)

        logging.basicConfig(
            level=logging.INFO, filename=os.path.join(log_dir, "yugabyte-db.log"), filemode="a",
            format="[%(filename)s:%(lineno)d] %(asctime)s %(levelname)s: %(message)s")

        args.func()

class Configs(object):
    def __init__(self, config_file):
        self.saved_data = {
            "data_dir": DEFAULT_DATA_DIR,
            "log_dir": DEFAULT_LOG_DIR,
            "master_port": DEFAULT_MASTER_PORT,
            "ysql_port": DEFAULT_YSQL_PORT,
            "ycql_port": DEFAULT_YCQL_PORT,
            "universe_uuid": "",
            "polling_interval": "5",
            "yb_demo_retail": False
        }
        self.config_file = config_file

    # Saves current configs to config file.
    def save_configs(self):
        formatted_configs = ""
        for k, v in get_kv(self.saved_data):
            formatted_configs += "{}: {}\n".format(k, v)
        with open(self.config_file, "w+") as f:
            f.write(formatted_configs)

    # Custom parser for reading config file.
    @staticmethod
    def parse_config_file(config_file):
        configs = Configs(config_file)
        if os.path.isfile(config_file):
            try:
                with open(config_file) as f:
                    config_regex = r"\w+: [\w\/\.-]+$"
                    for line in f:
                        if not re.match(config_regex, line):
                            log_error_and_exit(
                                "Failed to parse config file {}: {}".format(config_file, line))
                        k, v = line.split(": ")
                        configs.saved_data[k] = v.strip()
            except Exception as e:
                log_error_and_exit("Failed to read config file {}: {}".format(config_file, str(e)))
        return configs


class ProcessManager(object):
    def __init__(self, name, cmd, log_dir, data_dir):
        self.name = name
        self.cmd = cmd
        self.log_dir = log_dir
        self.data_dir = data_dir
        self.pidfile = os.path.join(self.data_dir, "{}.pid".format(name))
        self.process = None
        # TODO: Get uptime of process.
        self.start_time = None

    # Start process. Creates pidfile and corresponding output logs.
    def start(self):
        out_log = os.path.join(self.log_dir, "{}.out".format(self.name))
        err_log = os.path.join(self.log_dir, "{}.err".format(self.name))
        with open(out_log, "a") as out_log, open(err_log, "a") as err_log:
            self.process = subprocess.Popen(self.cmd, stdout=out_log, stderr=err_log)
            self.start_time = time.time()
        # TODO: Redirect YW logs to yugabyte-logs
        with open(self.pidfile, "w+") as pid_file:
            pid_file.write(str(self.process.pid))
            print_and_log("{} running with PID {}.".format(self.name, self.process.pid))

    # Returns pid of this process if it's running.
    def get_pid(self):
        if os.path.exists(self.pidfile):
            if self.process:
                return self.process.pid
            else:
                with open(self.pidfile, "r") as f:
                    try:
                        pid = int(f.readline())
                    except ValueError as e:
                        print_and_log(
                            "Could not parse int PID from {}. Deleting file.".format(self.pidfile),
                            logging.DEBUG)
                        self.delete_pidfile()
                        return None
                command = ProcessManager.get_command(pid)
                if command and self.name in command:
                    return pid

            print_and_log(
                "Pidfile {} was not properly deleted. Contained PID {}. Deleting file.".format(
                    self.pidfile, pid),
                logging.DEBUG)
            self.delete_pidfile()
        return None

    # Kills self.process if it exists.
    def kill(self):
        if self.process:
            self.process.kill()
        else:
            pid = self.process.get_pid()
            if pid:
                try:
                    os.kill(pid, signal.SIGTERM)
                except OSError as e:
                    pass
        self.delete_pidfile()

    # Delete corresponding pidfile for this process.
    def delete_pidfile(self):
        if os.path.exists(self.pidfile):
            try:
                os.remove(self.pidfile)
            except OSError as e:
                if os.path.exists(self.pidfile):
                    log_error_and_exit("Failed to delete {}.".format(self.pidfile))
        self.start_time = None

    # Check fatal errors in fatal/error logs, if any. Overwritten in YBProcessManager
    def check_fatals(self):
        pass

    # Returns process status.
    def is_running(self):
        self.check_fatals()
        return self.get_pid() and self.process and self.process.poll() is None

    # Returns the command that was run with the input pid.
    @staticmethod
    def get_command(pid):
        try:
            return subprocess.check_output(["ps", "-p", str(pid), "-o", "command="])
        except subprocess.CalledProcessError as e:
            return ""

    # Returns if process called name is running.
    @staticmethod
    def is_process_running(name, pid_dir):
        return ProcessManager(name, cmd="", log_dir="", data_dir=pid_dir).get_pid() is not None


class YBProcessManager(ProcessManager):
    def __init__(self, name, cmd, log_dir, data_dir):
        super(YBProcessManager, self).__init__(name, cmd, log_dir, data_dir)
        self.data_log_path = "{}/yb-data/{}/logs".format(data_dir, self.name)
        self.error_log = "{}/yb-{}.ERROR".format(self.data_log_path, self.name)


    def start(self):
        # Remove old logs as timestamped logs should have already been created.
        if os.path.isfile(self.error_log):
            os.remove(self.error_log)

        super(YBProcessManager, self).start()

        # Add symlink to the logs from log directory.
        log_path = os.path.join(self.log_dir, self.name)
        if not os.path.islink(log_path):
            try:
                os.symlink(self.data_log_path, log_path)
            except OSError as e:
                logging.error(
                    "Failed to create symlink from {} to {}".format(self.data_log_path, log_path))

    def check_fatals(self):
        # Error logs contain port information, but fatal logs don't.
        address_error_1 = "Could not start on address"
        address_error_2 = "Error binding socket to "
        if os.path.isfile(self.error_log):
            with open(self.error_log) as log:
                for line in log.readlines():
                    if address_error_1 in line:
                        err_msg = line.split(address_error_1)
                        # Try to find address, otherwise log entire error message.
                        if len(err_msg) == 2:
                            err_msg = err_msg[1]
                        else:
                            err_msg = line
                        log_error_and_exit(
                            "Failed to bind to address: {}. Is port open?".format(err_msg))
                    elif address_error_2 in line:
                        err_msg = line.split(address_error_2)[1]
                        address = err_msg.split(" ")[0]
                        log_error_and_exit(
                            "Failed to bind to address: {}. Is port open?".format(address))


class Diagnostics(object):
    def __init__(self, configs):
        self.configs = configs

    # Collects data.
    def get_data(self, processes):
        payload = {
            "data_dir_size": self.get_dir_size(self.configs.saved_data.get("data_dir")),
            "num_cpus": multiprocessing.cpu_count(),
        }
        for p in processes.values():
            payload["{}_status".format(p.name)] = "UP" if p.is_running() else "DOWN"
            if p.start_time:
                payload["{}_start_time".format(p.name)] = p.start_time

        data = {
            "cluster_uuid": "312b7810-1752-4fe2-94f1-8d2f6fc25251",
            "node_uuid": "312b7810-1752-4fe2-94f1-8d2f6fc25251",
            "server_type": "yugabyte-db",
            "timestamp": int(time.time()),
            "payload": payload
        }
        return json.dumps(data)

    def get_dir_size(self, dirname):
        size = 0
        for path, _, files in os.walk(dirname):
            for f in files:
                filepath = os.path.join(path, f)
                # Check that the file is not a symlink
                if os.path.isfile(filepath):
                    size += os.path.getsize(filepath)
        return size


# Proxy for ysqlsh commands.
class YsqlProxy(object):
    def __init__(self, port, path=os.path.join(BIN_DIR, YUGABYTE_API_CLIENT_PROGRAMS["ysql"])):
        self.port = port
        self.path = path

    # Starts interactive YSQL shell.
    def connect(self, db=None):
        cmd = [self.path, "-p", self.port]
        if db:
            cmd.extend(["-d", db])
        os.execv(self.path, cmd)

    # Checks if db exists.
    # Note that this will return false if ysqlsh can't connect, even if db exists.
    def db_exists(self, db):
        cmd = [self.path, "-p", self.port, "-q", "-c", "\\t", "-c",
            "select datname from pg_catalog.pg_database where datname='{}'".format(db)]
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        return out.strip() == db

    # Creates specified db.
    def create_db(self, db):
        cmd = [self.path, "-p", self.port, "-c", "create database {}".format(db)]
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        return out, err

    # Deletes specified db.
    def drop_db(self, db):
        cmd = [self.path, "-p", self.port, "-c", "drop database {}".format(db)]
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        return out, err

    # Runs ysqlsh with specified files.
    def load_files(self, filepaths, db=None):
        cmd = [self.path, "-p", self.port]
        if db:
            cmd.extend(["-d", db])
        for path in filepaths:
            cmd.extend(["-f", path])
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = p.communicate()
        return out, err


# Currently unused. Useful for getting diagnostics that are available only through logs.
class LogAnalyzer(object):
    unsupported_error = "not supported yet"
    def __init__(self, logfile):
        self.logfile = logfile
        # Flag to stop tailing the logfile.
        self.kill_thread = False
        self.unsupported_commands = []

    def analyze(self):
        lines = self.tail()
        for line in lines:
            if LogAnalyzer.unsupported_error in line:
                # Get the command logged right before error message
                cmd = line.split("not supported yet")[0].split()[-1]
                self.unsupported_commands.append(cmd)

    # Generator that continually returns last line of logfile.
    def tail(self):
        with open(self.logfile) as open_file:
            open_file.seek(0, 2)
            while not self.kill_thread:
                line = open_file.readline()
                if not line:
                    time.sleep(0.1)
                    continue
                yield line


def print_and_log(msg, level=logging.INFO):
    print(msg)
    if level == logging.CRITICAL:
        logging.critical(msg)
    elif level == logging.ERROR:
        logging.error(msg)
    elif level == logging.WARNING:
        logging.warning(msg)
    elif level == logging.INFO:
        logging.info(msg)
    elif level == logging.DEBUG:
        logging.debug(msg)

def log_error_and_exit(msg):
    print_and_log(msg, logging.ERROR)
    sys.exit(1)

# Returns key-value pairs of input dict. Independent of python version.
def get_kv(map):
    if PY_VERSION < 3:
        return map.iteritems()
    else:
        return map.items()

if __name__ == '__main__':
    YugaByteProcessManager().run()
